## 2020 Project 1

Εκφώνηση: https://k08.chatzi.org/projects/project1/



### Προσωπικά στοιχεία

__Όνομα__: Σκευοφύλακα Μαρία

__Α.Μ.__: sdi1900173


### Documentation

Συμπληρώστε εδώ __όσο documentation χρειάζεται__ ώστε οι βαθμολογητές να
κατανοήσουν πλήρως τις λύσεις σας και να τις βαθμολογήσουν ανάλογα. Αυτό θα
πρέπει να γίνει ανεξάρτητα με το αν ο κώδικάς σας είναι καλά σχολιασμένος,
πράγμα που συνιστάται.


Άσκηση 2η: (../programs/exercise2)
Παρατηρώ ότι καθώς αυξάνεται το μέγεθος της εισόδου αυξάνεται και ο χρόνος εκτέλεσης.

Ειδικότερα για ν=10 το πρόγραμμα χρειάζεται 0.000s,για ν=100 χρειάζεται 0.000s,για ν=1.000,0.004s,για ν=10.000 0.021s και για ν=100.000 το πρόγραμμα χρειάζεται 0.218s.

Παρατηρώ ότι αυτοί οι χρόνοι είναι εμφανώς πολύ μικρότεροι από αυτούς της προηγούμενης άσκησης που εκτελούσε την ίδια διαδικασία χωρίς τη χρήση Map.


Άσκηση 3η: (../programs/exercise3)
Στην υλοποίηση της 3ης άσκησης η ιδέα είναι η εξής:
Δημιουργείται ένα set στο οποίο εισάγονται όλα τα στοιχεία που δίνει ο χρήστης. Δεδομένου ότι το set τοποθετεί τα στοιχεία σύμφωνα με μία συνάρτηση compare,το μικρότερο από τα μεγαλύτερα ή ίσα στοιχεία που έχουν ήδη δωθεί είναι αυτό που βρίσκεται στην επόμενη θέση του set από το δοσμένο. Συνεπώς σε μία μεταβλητή node τοποθετείται το επόμενο στοιχείο από το δοσμένο. Αν αυτό είναι διαφορετικό απο το SET_EOF τότε αν το value του είναι και αυτό διαφορετικό από NULL τότε εκτυπώνεται. Αλλιώς none.

Άσκηση 4: (../modules/pq_sort ../tests/pqsort_test)
Στην υλοποίηση του pq_sort_vector η ιδέα είναι ότι δημιουργούμε μία priority queue με τα στοιχεία του vector και στη συνέχεια τα τοποθετούμε από το τέλος προς την αρχή του vector με τη σειρά που τα επιστρέφει η priority queue.

Όσον αφορά την pq_sort_list δημιουργούμε ένα vector με τα στοιχεία του list και στη συνέχεια το ταξινομούμε χρησιμοποιώντας την προηγούμενη συνάρτηση. Στη συνέχεια ξεκινώντας από το LIST_BOF αφαιρούμε το επόμενο στοιχείο από τον δοσμένο κόμβο και το ξαναεισάγουμε από τον ταξινομημένο πλέον vector.


Άσκηση 5: (../modules/life ../tests/lifestate_test.c ../include/lifestate.h)
Η βασική ιδέα είναι η υλοποίηση των συγκεκριμένων συναρτήσεων μέσω των γνωστών συναρτήσεων του ADTMap.
Στην συνάρτηση create δημιουργείται ένα map με δοσμένες συναρτήσεις compare,destroy. Στην create_from_rle διαβάζονται διαδοχικά χαρακτήρες από την είσοδο μέχρις ώτου να διαβαστεί το ! που σηματοδοτεί το τέλος του rle format. Για κάθε χαρακτήρα εξετάζεται αν είναι ίσος με b,o,$,! ή αν είναι κάποιος αριθμός και ανάλογα εκτελούνται οι αντίστοιχες λειτουργίες.Η life_save_to_rle για κάθε ζεύγος χ,y βρίσκει αν ανήκει ή όχι στη δομή και μετράει τα συνεχόμενα νεκρά ή ζωντανά κελιά και τα τυπώνει μόλις βρεθεί ένα του άλλου είδους. Στην set_cell εξετάζεται αν υπάρχει το στοιχείο μέσα στο state και ανάλογα με την τιμή του value εκτελεί την αντίστοιχη λειτουργία. Αντίστοιχα η get_cell ψάχνει το στοιχείο μέσα στο LifeState και αντίστοιχα επιστρέφει 0 ή 1. Ή life evolve βρίσκει τα άκρα του πίνακα +-1 και για κάθε συνδυασμό χ,y εντοπίζει τους ζωντανούς γείτονες και δημιουργεί μία νέα εξέλιξη σύμφωνα με τους κανόνες του παιχνιδιού. Η life_destroy καταστρέφει το LifeState καλώντας την map_destroy. Στα tests δημιουργούνται κάποιες συγκεκριμένες καταστάσεις και εξετάζεται η συμπεριφορά των συναρτήσεων για κάθε μία εξ αυτών.


Άσκηση 6: (../programs/exercise6)
Στην συγκεκριμένη υλοποίηση δημιουργείται ένα Gif(με δοσμένες παραμέτρους από το makefile αρχείο) στο οποίο για κάθε frame του χρωματίζονται με άσπρο τα ζωντανά κελιά και κάθε frame είναι speed εξελίξεις μετά το προηγούμενο του.
